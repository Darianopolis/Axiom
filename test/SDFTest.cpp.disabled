#include <nova/rhi/nova_RHI.hpp>
#include <nova/ui/nova_ImGui.hpp>

#include <GLFW/glfw3.h>
#include <GLFW/glfw3native.h>

#include <stb_image.h>

using namespace nova::types;

static Mat4 ProjInfReversedZRH(f32 fovY, f32 aspectWbyH, f32 zNear)
{
    // https://nlguillemot.wordpress.com/2016/12/07/reversed-z-in-opengl/

    f32 f = 1.f / glm::tan(fovY / 2.f);
    Mat4 proj{};
    proj[0][0] = f / aspectWbyH;
    proj[1][1] = f;
    proj[3][2] = zNear; // Right, middle-bottom
    proj[2][3] = -1.f;  // Bottom, middle-right

    return proj;
}

struct RayTrace_PC
{
    Vec3            pos;
    Vec3           camX;
    Vec3           camY;
    f32      camZOffset;

    f32   scale;
    f32 epsilon;
    f32 coneGradient;

    static constexpr auto Layout = std::array {
        nova::Member{"pos",             nova::ShaderVarType::Vec3},
        nova::Member{"camX",            nova::ShaderVarType::Vec3},
        nova::Member{"camY",            nova::ShaderVarType::Vec3},
        nova::Member{"camZOffset",      nova::ShaderVarType::F32},

        nova::Member{"scale",   nova::ShaderVarType::F32},
        nova::Member{"epsilon", nova::ShaderVarType::F32},
        nova::Member{"coneGradient", nova::ShaderVarType::F32},
    };
};

void TryMain();

int main()
{
    try {
        TryMain();
    }
    catch (const std::exception& e) {
        NOVA_LOG("Error - {}", e.what());
    }
    catch (...) {
        NOVA_LOG("Error - ...");
    }
}

void TryMain()
{

// -----------------------------------------------------------------------------
//                             GLFW Initialization
// -----------------------------------------------------------------------------

    glfwInit();
    glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API);
    auto window = glfwCreateWindow(1929, 1080, "Nova - Compute", nullptr, nullptr);
    NOVA_CLEANUP(&) {
        glfwDestroyWindow(window);
        glfwTerminate();
    };

    i32 width, height;
    glfwGetFramebufferSize(window, &width, &height);

// -----------------------------------------------------------------------------
//                             Nova Initialization
// -----------------------------------------------------------------------------

    auto context = nova::Context::Create({
        .debug = false,
    });
    NOVA_CLEANUP(&) { context.Destroy(); };

    // Create surface and swapchain for GLFW window

    auto swapchain = nova::Swapchain::Create(context, glfwGetWin32Window(window),
        nova::TextureUsage::Storage
        | nova::TextureUsage::TransferDst
        | nova::TextureUsage::ColorAttach,
        nova::PresentMode::Immediate);
    NOVA_CLEANUP(&) { swapchain.Destroy(); };

    // Create required Nova objects

    auto queue = context.GetQueue(nova::QueueFlags::Graphics, 0);
    auto cmdPool = nova::CommandPool::Create(context, queue);
    auto fence = nova::Fence::Create(context);
    auto heap = nova::DescriptorHeap::Create(context, 3);
    NOVA_CLEANUP(&) {
        cmdPool.Destroy();
        fence.Destroy();
        heap.Destroy();
    };

    // Image

    auto sampler = nova::Sampler::Create(context, nova::Filter::Linear, nova::AddressMode::Edge, {}, 16.f);
    NOVA_CLEANUP(&) { sampler.Destroy(); };
    heap.WriteSampler(0, sampler);

    // ImGui

    auto imgui = nova::ImGuiLayer({
        .window = window,
        .context = context,
        .heap = heap,
        .sampler = 0,
        .fontTextureID = 1,
    });

    // Shaders

    auto computeShader = nova::Shader::Create(context, nova::ShaderStage::Compute, {
        nova::shader::PushConstants("pc", RayTrace_PC::Layout),
        nova::shader::Fragment(R"glsl(

            #define SCALE 2.8
            #define MINRAD2 .25
            float minRad2 = clamp(MINRAD2, 1.0e-9, 1.0);
            #define SCALE4 (vec4(SCALE, SCALE, SCALE, abs(SCALE)) / minRad2)
            float absScalem1 = abs(SCALE - 1.0);
            float AbsScaleRaisedTo1mIters = pow(abs(SCALE), float(1-10));

            float sdFractal(vec3 p)
            {
                float s = 3.0f, e;
                for (int i = 0; i++ < 24;) {
                    // p = mod(p - 1.0f, 2.0f) - 1.0f;
                    p = abs(fract(p * 0.5 - 0.5) * 2.0 - 1.0);
                    s *= e = 1.4f / dot(p, p);
                    p *= e;
                }
                return length( p.yz ) / s;
            }

            float sdBox( vec3 p, vec3 b )
            {
                vec3 q = abs(p) - b;
                return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
            }

            // float mdbDE(vec3 c) {
            //     vec3 z = c;
            //     float dr = 1.0;
            //     float r = length(z);
            //     for (int i = 0; i < 6 && r < 2.0; i++) {
            //         float powr = pow(r, 7.0);
            //         dr = dr * powr * 8.0 + 1.0;
            //         float theta = acos(z.z / r) * 8.0;
            //         float phi = atan(z.y, z.x) * 8.0;
            //         z = r * powr * vec3(sin(theta) * vec2(cos(phi), sin(phi)), cos(theta)) + c;
            //         r = length(z);
            //     }
            //     return min(0.5 * log(r) * r / dr, 1.0);
            // }

            // float sdFractal(vec3 p) {
            //     float s = 3.0f, e;
            //     float trap = 1000.0;
            //     for ( int i = 0; i++ < 8; ) {
            //         p = mod( p - 1.0f, 2.0f ) - 1.0f;
            //         s *= e = 1.4f / dot( p, p );
            //         p *= e;
            //         trap = min(trap, mdbDE(p - vec3(2.88, -0.93, -0.93)) / s);
            //     }
            //     return trap;
            // }

            float sdRoundBox(vec3 p, vec3 b, float r)
            {
                vec3 q = abs(p) - b;
                return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
            }

            float map(vec3 pos)
            {
                // // float res = sdRoundBox(pos, vec3(1, 2, 3), 0.25);
                // float res = sdFractal(pos);

                // return res;

                vec4 p = vec4(pos,1);
                vec4 p0 = p;  // p.w is the distance estimate

                for (int i = 0; i < 9; i++)
                {
                    p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;

                    float r2 = dot(p.xyz, p.xyz);
                    p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);

                    // scale, translate
                    p = p*SCALE4 + p0;
                }
                return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);
            }

            vec3 calcNormal(vec3 pos)
            {
                vec3 n = vec3(0);
                for (int i = 0; i < 4; ++i) {
                    vec3 e = 0.5773 * (2.0 * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.0);
                    n += e * map(pos + 0.0005 * e).x;
                }

                return normalize(n);
            }
        )glsl"),
        nova::shader::ComputeKernel(Vec3U(16u, 16u, 1u), R"glsl(
            ivec2 launchPos = ivec2(gl_GlobalInvocationID.xy);
            ivec2 launchSize = ivec2(gl_WorkGroupSize * gl_NumWorkGroups);

            // vec2 uv = vec2(pos) / (vec2(gl_NumWorkGroups.xy) * vec2(gl_WorkGroupSize.xy));

            vec2 pixelCenter = vec2(launchPos.xy);
            pixelCenter += vec2(0.5);
            vec2 inUV = pixelCenter / vec2(launchSize.xy);
            vec2 d = inUV * 2.0 - 1.0;
            vec3 focalPoint = pc.camZOffset * cross(pc.camX, pc.camY);
            vec3 pos = pc.pos * vec3(pc.scale);

            // Perspective
            d.x *= float(launchSize.x) / float(launchSize.y);
            d.y *= -1.0;
            vec3 dir = normalize((pc.camY * d.y) + (pc.camX * d.x) - focalPoint);

            float coneRadius = 0.0001f;

            // Raymarch
            bool found = false;
            for (int s = 0; s < 256; ++s) {
                float dist = map(pos);
                if (dist < pc.epsilon * coneRadius * pc.scale) {
                    found = true;
                    break;
                }
                pos += vec3(dist) * dir;
                coneRadius += dist * pc.coneGradient;
            }

            // vec3 color = found ?  : vec3(dir * 0.5 + 0.5);
            vec3 color = found ? calcNormal(pos) * 0.5 + 0.5 : vec3(0.2);

            imageStore(StorageImage2D_rgba8[2], launchPos, vec4(color, 1.0));
        )glsl"),
    });
    NOVA_CLEANUP(&) { computeShader.Destroy(); };

// -----------------------------------------------------------------------------
//                               Main Loop
// -----------------------------------------------------------------------------

    static f32 moveSpeed = 1.0;
    Vec3 position = Vec3(0.f, 0.f, 2.f);

    bool lastMouseDrag = false;
    float mouseSpeed = 0.0025f;
    POINT savedPos = {};
    Quat rotation = Vec3(0.f);

    // Raymarching attributes

    f32   scale = 1.f;
    f32 epsilon = 0.00001f;
    f32 coneGradient = 100.f;

    // ----

    u64 frames = 0;
    f32 fps = 0;
    std::chrono::steady_clock::time_point lastUpdateTime;
    std::chrono::steady_clock::time_point lastReportTime;

    glfwSetScrollCallback(window, [](auto, f64, f64 dy) {
        if (dy > 0) { moveSpeed *= 1.25f; }
        if (dy < 0) { moveSpeed /= 1.25f; }
    });

    NOVA_CLEANUP(&) { fence.Wait(); };
    while (!glfwWindowShouldClose(window)) {

        fence.Wait();

        // Frame times

        using namespace std::chrono;
        auto now = steady_clock::now();
        auto timeStep = duration_cast<duration<f32>>(now - lastUpdateTime).count();
        lastUpdateTime = now;

        // Debug output statistics

        frames++;
        if (now - lastReportTime > 1s) {
            auto delta = duration_cast<duration<f32>>(now - lastReportTime).count();
            fps = frames / delta;
            lastReportTime = std::chrono::steady_clock::now();
            frames = 0;
        }

        // Camera

        {
            Vec3 translate = {};
            if (glfwGetKey(window, GLFW_KEY_W))          translate += Vec3( 0.f,  0.f, -1.f);
            if (glfwGetKey(window, GLFW_KEY_A))          translate += Vec3(-1.f,  0.f,  0.f);
            if (glfwGetKey(window, GLFW_KEY_S))          translate += Vec3( 0.f,  0.f,  1.f);
            if (glfwGetKey(window, GLFW_KEY_D))          translate += Vec3( 1.f,  0.f,  0.f);
            if (glfwGetKey(window, GLFW_KEY_LEFT_SHIFT)) translate += Vec3( 0.f, -1.f,  0.f);
            if (glfwGetKey(window, GLFW_KEY_SPACE))      translate += Vec3( 0.f,  1.f,  0.f);
            if (translate.x || translate.y || translate.z) {
                position += rotation * (glm::normalize(translate) * moveSpeed * timeStep);
            }
        }

        {
            Vec2 delta = {};
            if (GetFocus() == glfwGetWin32Window(window) && glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_2)) {
                POINT p;
                GetCursorPos(&p);
                LONG dx = p.x - savedPos.x;
                LONG dy = p.y - savedPos.y;
                if (lastMouseDrag) {
                    delta = { f32(dx), f32(dy) };
                }
                else {
                    GetCursorPos(&savedPos);
                    ShowCursor(false);
                    lastMouseDrag = true;
                }
                SetCursorPos(savedPos.x, savedPos.y);
            }
            else if (lastMouseDrag) {
                ShowCursor(true);
                lastMouseDrag = false;
            }

            if ((delta.x || delta.y) && glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_2)) {
                rotation = glm::angleAxis(delta.x * mouseSpeed, Vec3(0.f, -1.f, 0.f)) * rotation;
                rotation = rotation * glm::angleAxis(delta.y * mouseSpeed, Vec3(-1.f, 0.f, 0.f));
                rotation = glm::normalize(rotation);
            }
        }

        int cWidth, cHeight;
        glfwGetFramebufferSize(window, &cWidth, &cHeight);
        f32 fov = glm::radians(90.f);
        auto proj = ProjInfReversedZRH(fov, f32(cWidth) / cHeight, 0.01f);
        auto view = glm::affineInverse(glm::translate(Mat4(1.f), glm::vec3(position)) * glm::mat4_cast(rotation));
        auto viewProj = proj * view;

        // Wait for previous frame and acquire new swapchain image

        queue.Acquire({swapchain}, {fence});
        auto target = swapchain.GetCurrent();

        // Start new command buffer

        cmdPool.Reset();
        auto cmd = cmdPool.Begin();

        // Transition ready for writing compute output

        cmd.Transition(target,
            nova::TextureLayout::GeneralImage,
            nova::PipelineStage::Compute);

        // Update target descriptor

        heap.WriteStorageTexture(2, target);
        cmd.BindDescriptorHeap(nova::BindPoint::Compute, heap);

        // Dispatch

        cmd.BindShaders({computeShader});
        cmd.PushConstants(RayTrace_PC {
            .pos = position,
            .camX = rotation * Vec3(1.f, 0.f, 0.f),
            .camY = rotation * Vec3(0.f, 1.f, 0.f),
            .camZOffset = 1.f / glm::tan(0.5f * fov),

            .scale = scale,
            .epsilon = epsilon,
            .coneGradient = coneGradient,
        });
        cmd.Dispatch(Vec3U((Vec2U(target.GetExtent()) + 15u) / 16u, 1));

        // Draw ImGui

        imgui.BeginFrame();
        if (ImGui::Begin("Settings")) {
            NOVA_CLEANUP() { ImGui::End(); };

            ImGui::Text("%s", NOVA_FORMAT_TEMP("Frametime = {:.3f} ({} fps)", 1.f / fps, fps).c_str());

            ImGui::Separator();

            ImGui::DragFloat("Speed", &moveSpeed, 0.01f);
            ImGui::DragFloat("Scale", &scale, 0.01f);
            ImGui::DragFloat("Epsilon", &epsilon, 0.00001f);
            ImGui::DragFloat("Cone Gradient", &coneGradient, 0.00001f);

            ImGui::Separator();

            ImGui::DragFloat3("Position", glm::value_ptr(position));
            if (ImGui::DragFloat4("Rotation", glm::value_ptr(rotation), 0.001f)) {
                rotation = glm::normalize(rotation);
            }
        }
        imgui.DrawFrame(cmd, swapchain.GetCurrent(), fence);

        // Submit and present work

        cmd.Present(swapchain);
        queue.Submit({cmd}, {fence}, {fence});
        queue.Present({swapchain}, {fence});

        // Wait for window events

        glfwPollEvents();
    }
}